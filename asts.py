# DO NOT EDIT THIS FILE
from dataclasses import dataclass, field

from typing import Optional

from .tokens import Token, Span
from .symbols import (
    Phony_Type,
    Phony_Scope,
    Phony_Symbol,
    Symbol,
    SemanticType,
    Scope,
)


@dataclass(slots=True)
class AST:
    span: Span  # The span of ALL tokens represented by this AST node


@dataclass(slots=True)
class Expr(AST):
    semantic_type: SemanticType = field(init=False, default_factory=Phony_Type)
    register: str = field(init=False, default="PHONY_REGISTER")


@dataclass(slots=True)
class Id(AST):
    token: Token

    symbol: Symbol = field(init=False, default_factory=Phony_Symbol)
    semantic_type: SemanticType = field(init=False, default_factory=Phony_Type)


@dataclass(slots=True)
class TypeAST(AST):
    semantic_type: SemanticType = field(init=False, default_factory=Phony_Type)


@dataclass(slots=True)
class Decl(AST):
    semantic_type: SemanticType = field(init=False, default_factory=Phony_Type)


@dataclass(slots=True)
class VarDecl(Decl):
    id: Id
    type_ast: TypeAST


@dataclass(slots=True)
class ParamDecl(Decl):
    id: Id
    type_ast: TypeAST


@dataclass(slots=True)
class IntTypeAST(TypeAST):
    token: Token


@dataclass(slots=True)
class BoolTypeAST(TypeAST):
    token: Token


@dataclass(slots=True)
class VoidTypeAST(TypeAST):
    token: Token


@dataclass(slots=True)
class ArrayTypeAST(TypeAST):
    length: Token
    element_type_ast: TypeAST


@dataclass(slots=True)
class Stmt(AST):
    pass


@dataclass(slots=True)
class PrintStmt(Stmt):
    expr: Expr


@dataclass(slots=True)
class CompoundStmt(Stmt):
    decls: list[VarDecl]
    stmts: list[Stmt]

    local_scope: Scope = field(init=False, default_factory=Phony_Scope)


@dataclass(slots=True)
class FuncDecl(Decl):
    id: Id
    params: list[ParamDecl]
    ret_type_ast: TypeAST
    body: CompoundStmt

    func_scope: Scope = field(init=False, default_factory=Phony_Scope)
    ar_size: int = field(init=False, default=9999999999)
    register_pool: list[str] = field(init=False, default_factory=list)


@dataclass(slots=True)
class Argument(AST):
    expr: Expr

    semantic_type: SemanticType = field(init=False, default_factory=Phony_Type)


@dataclass(slots=True)
class CallExpr(Expr):
    fn: Expr
    args: list[Argument]


@dataclass(slots=True)
class AssignStmt(Stmt):
    lhs: Expr
    rhs: Expr


@dataclass(slots=True)
class IfStmt(Stmt):
    expr: Expr
    thenStmt: CompoundStmt
    elseStmt: Optional[CompoundStmt]


@dataclass(slots=True)
class WhileStmt(Stmt):
    expr: Expr
    stmt: CompoundStmt


@dataclass(slots=True)
class CallStmt(Stmt):
    call: CallExpr


@dataclass(slots=True)
class ReturnStmt(Stmt):
    expr: Optional[Expr]


@dataclass(slots=True)
class BinaryOp(Expr):
    op: Token
    left: Expr
    right: Expr


@dataclass(slots=True)
class UnaryOp(Expr):
    op: Token
    expr: Expr


@dataclass(slots=True)
class ArrayCell(Expr):
    arr: Expr
    idx: Expr


@dataclass(slots=True)
class IntLiteral(Expr):
    token: Token


@dataclass(slots=True)
class BoolLiteral(Expr):
    token: Token
    value: bool


@dataclass(slots=True)
class IdExpr(Expr):
    id: Id


@dataclass(slots=True)
class Program(AST):
    decls: list[FuncDecl]

    register_pool: list[str] = field(init=False, default_factory=list)
